<!DOCTYPE html>
<html lang="ru">
<head>
    <meta name="monetag" content="44db13eefe948a008f60b98cdf77d870">
    <script src="https://fpyf8.com/88/tag.min.js" data-zone="187791" async data-cfasync="false"></script>
    <script>(function(s){s.dataset.zone='10234615',s.src='https://groleegni.net/vignette.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>
    <meta charset="UTF-8" />
	<link rel="icon" href="/for site.png" type="image/png" sizes="64x64">
    <meta name="description" content="Подробное руководство о том, как подготовиться и выиграть олимпиаду по информатике: советы, стратегии и ресурсы.">
    <meta name="robots" content="index, follow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Как стать лучшим на Олимпиаде</title>
    <style>
        body {
            font-family: Arial, sans-serif;
	    width: 100%;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: #f4f4f4;
        }
        header {
		width: 100%;
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #89f7fe, #66a6ff);
      display: flex;
	flex-direction: column;
      align-items: center;
      height: 15vh;
      color: #fff;
        }
        nav {
		width: 100%;
            background-color: #34495e;
            display: flex;
            justify-content: center;
        }
        nav a {
		width: 100%;
            color: white;
            padding: 14px 20px;
            text-decoration: none;
            transition: background 0.3s;
        }
        nav a:hover {
		width: 100%;
            background-color: #1abc9c;
        }
        section {
		width: 100%;
            padding: 20px;
            margin: auto;
        }
        footer {
            background-color: #2c3e50;
            color: white;
            text-align: center;
            padding: 10px;
            margin-top: 20px;
        }
        h1, h2 {
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <header>
        <h1>Как стать лучшим на Олимпиаде</h1>
        <p>Путеводитель к олимпийскому успеху</p>
    </header>
    <section id="obuchenie">
        <h2>План обучения</h2>
        <p><ol>
    <li>Линейный поиск</li>
    <li>Бинарный поиск (двоичный поиск)</li>
    <li>Сортировка (быстрая, слиянием, пирамидальная)</li>
    <li>Рекурсия и возведение в степень</li>
    <li>Жадные алгоритмы (Greedy Algorithms)</li>
    <li>Динамическое программирование (ДП)</li>
    <li>Стек и Очередь (Stack & Queue)</li>
    <li>Система непересекающихся множеств (Disjoint Set Union - DSU)</li>
    <li>Хеш-таблицы (Hash Tables)</li>
    <li>Дерево отрезков (Segment Tree)</li>
    <li>Поиск в ширину (Breadth-First Search - BFS)</li>
    <li>Поиск в глубину (Depth-First Search - DFS)</li>
    <li>Алгоритм Дейкстры (поиск кратчайшего пути)</li>
    <li>Алгоритм Флойда-Уоршелла (все пары кратчайших путей)</li>
    <li>Алгоритм Прима или Краскала (поиск минимального остовного дерева)</li>
    <li>Алгоритм Евклида (нахождение НОД)</li>
    <li>Решето Эратосфена (поиск простых чисел)</li>
    <li>Бинарные подъемы (Binary Lifting) для LCA (наименьший общий предок)</li>
    <li>Метод двух указателей (Two Pointers Technique)</li>
    <li>Алгоритм Кнута-Морриса-Пратта (КМП) (поиск подстроки)</li>
	</ol>
	</p>
    </section>
	<section id="linear-search-explanation">
    <h1>Линейный поиск (Linear Search)</h1>
    <p>
        Линейный поиск, также известный как последовательный поиск, — это простой алгоритм поиска элемента в списке или массиве.
        Он работает путем последовательной проверки каждого элемента в массиве, пока не будет найден искомый элемент или пока список не закончится.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Алгоритм выполняет следующие шаги:
    </p>
    <ul>
        <li>Начинает поиск с первого элемента массива.</li>
        <li>Сравнивает текущий элемент с искомым (целевым) значением.</li>
        <li>Если элементы совпадают, возвращает индекс текущего элемента (поиск завершен).</li>
        <li>Если нет совпадения, переходит к следующему элементу и повторяет процесс.</li>
        <li>Если весь массив просмотрен, а элемент не найден, возвращает специальное значение (например, -1 или null), указывающее на отсутствие элемента.</li>
    </ul>

    <h2>Пример кода на JavaScript</h2>
    <p>
        Ниже представлен код функции на JavaScript, реализующей линейный поиск.
    </p>
    <pre>
        <code>
function linearSearch(arr, target) {
    // Перебираем все элементы массива от начала до конца
    for (let i = 0; i < arr.length; i++) {
        // Если текущий элемент совпадает с целевым, возвращаем его индекс
        if (arr[i] === target) {
            return i;
        }
    }
    // Если элемент не найден после просмотра всего массива, возвращаем -1
    return -1;
}

// Пример использования:
const dataArray = [10, 25, 38, 45, 50, 67];
const targetValue = 45;
const resultIndex = linearSearch(dataArray, targetValue);

if (resultIndex !== -1) {
    console.log(`Элемент найден по индексу: ${resultIndex}`);
} else {
    console.log("Элемент не найден");
}
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Временная сложность линейного поиска в худшем случае составляет O(n), где n — количество элементов в списке, так как может потребоваться проверить каждый элемент.
        В лучшем случае, если целевой элемент находится в самом начале, сложность будет O(1).
    </p>
</section>
<section id="binary-search-explanation">
    <h1>Бинарный поиск (Binary Search)</h1>
    <p>
        Бинарный поиск, также известный как метод деления пополам, — это эффективный алгоритм поиска элемента в <strong>отсортированном</strong> массиве.
        Он значительно быстрее линейного поиска, но требует, чтобы исходные данные были упорядочены.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Ключевая идея бинарного поиска — многократное деление диапазона поиска пополам. Алгоритм выполняет следующие шаги:
    </p>
    <ul>
        <li>Определяет средний элемент в текущем диапазоне поиска.</li>
        <li>Сравнивает средний элемент с искомым (целевым) значением.</li>
        <li>Если они совпадают, элемент найден, и его индекс возвращается.</li>
        <li>Если целевое значение меньше среднего элемента, поиск продолжается только в левой половине диапазона.</li>
        <li>Если целевое значение больше среднего элемента, поиск продолжается только в правой половине диапазона.</li>
        <li>Эти шаги повторяются до тех пор, пока элемент не будет найден, или пока диапазон поиска не сузится до нуля (элемент отсутствует).</li>
    </ul>

    <h2>Пример кода на JavaScript (итеративная реализация)</h2>
    <p>
        Ниже представлен код функции на JavaScript, реализующей итеративный бинарный поиск.
    </p>
    <pre>
        <code>
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        // Находим средний индекс (используем Math.floor для целого числа)
        let mid = Math.floor((left + right) / 2);

        // Проверяем, находится ли целевое значение в середине
        if (arr[mid] === target) {
            return mid; // Элемент найден
        }

        // Если целевое значение больше среднего, игнорируем левую половину
        if (arr[mid] < target) {
            left = mid + 1;
        }
        // Если целевое значение меньше среднего, игнорируем правую половину
        else {
            right = mid - 1;
        }
    }

    // Если цикл завершился, элемент не найден
    return -1;
}

// Пример использования (массив ДОЛЖЕН быть отсортирован):
const sortedArray =;
const targetValue = 42;
const resultIndex = binarySearch(sortedArray, targetValue);

if (resultIndex !== -1) {
    console.log(`Элемент найден по индексу: ${resultIndex}`);
} else {
    console.log("Элемент не найден");
}
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Бинарный поиск значительно эффективнее линейного. Его временная сложность составляет <strong>O(log n)</strong> (логарифмическая), что означает, что количество шагов увеличивается очень медленно с ростом размера массива $n$. Это делает его предпочтительным выбором для поиска в больших отсортированных наборах данных.
    </p>
</section>
<section id="quicksort-explanation">
    <h1>Быстрая сортировка (Quicksort)</h1>
    <p>
        Быстрая сортировка — это эффективный алгоритм сортировки, основанный на принципе «разделяй и властвуй». В среднем это один из самых быстрых алгоритмов сортировки. Он работает путем выбора «опорного» (pivot) элемента и разделения других элементов на два подмассива в зависимости от того, меньше они или больше опорного.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Алгоритм выполняет следующие шаги:
    </p>
    <ul>
        <li>Выбирается опорный элемент из массива.</li>
        <li>Элементы массива перераспределяются таким образом, что все элементы меньше опорного оказываются до него, а все элементы больше опорного — после. Этот процесс называется <strong>разделением (partitioning)</strong>.</li>
        <li>Два получившихся подмассива (до и после опорного элемента) рекурсивно сортируются тем же способом.</li>
        <li>Сортировка происходит «на месте» (in-place), не требуя значительной дополнительной памяти.</li>
    </ul>

    <h2>Пример кода на JavaScript (реализация "на месте")</h2>
    <pre>
        <code>
function quickSort(arr, left = 0, right = arr.length - 1) {
    if (left < right) {
        let pivotIndex = partition(arr, left, right);
        // Рекурсивно сортируем левую и правую части
        quickSort(arr, left, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, right);
    }
    return arr;
}

function partition(arr, left, right) {
    let pivot = arr[right]; // Выбираем последний элемент как опорный
    let i = left - 1; // Указатель на меньший элемент

    for (let j = left; j < right; j++) {
        if (arr[j] <= pivot) {
            i++;
            // Меняем arr[i] и arr[j] местами
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    // Меняем опорный элемент (arr[right]) и arr[i+1] местами
    [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
    return i + 1;
}

// Пример использования:
const dataArrayQuick = [11, 8, 14, 3, 6, 2, 7, 1];
console.log("Отсортированный массив (Quicksort):", quickSort(dataArrayQuick));
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Средняя временная сложность быстрой сортировки составляет **O(n log n)**. В худшем случае (например, если массив уже отсортирован, а опорный элемент всегда выбирается неудачно), сложность может возрасти до O(n²), хотя рандомизация выбора опорного элемента помогает этого избежать.
    </p>
</section>

<section id="merge-sort-explanation">
    <h1>Сортировка слиянием (Merge Sort)</h1>
    <p>
        Сортировка слиянием — это еще один эффективный алгоритм сортировки, также использующий подход «разделяй и властвуй». Он был изобретен Джоном фон Нейманом в 1945 году. Он гарантирует высокую производительность независимо от начального состояния массива и особенно эффективен для сортировки связанных списков или внешних данных.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Алгоритм состоит из двух основных частей:
    </p>
    <ul>
        <li><strong>Разделение (Splitting):</strong> Массив рекурсивно делится пополам до тех пор, пока каждый подмассив не будет состоять всего из одного элемента (который по определению уже отсортирован).</li>
        <li><strong>Слияние (Merging):</strong> Отсортированные подмассивы последовательно объединяются (сливаются) обратно в один большой отсортированный массив. Слияние двух отсортированных списков — это ключевой шаг, где происходит основная работа.</li>
    </ul>

    <h2>Пример кода на JavaScript</h2>
    <pre>
        <code>
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr; // Базовый случай: массив из 0 или 1 элемента уже отсортирован
    }

    const middle = Math.floor(arr.length / 2);
    const left = arr.slice(0, middle);
    const right = arr.slice(middle);

    // Рекурсивно сортируем обе половины и затем сливаем их
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
    let result = [];
    let leftIndex = 0;
    let rightIndex = 0;

    // Пока есть элементы в обеих половинах, сравниваем их и добавляем меньший
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }

    // Добавляем оставшиеся элементы из любой половины
    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}

// Пример использования:
const dataArrayMerge = [11, 8, 14, 3, 6, 2, 7, 1];
console.log("Отсортированный массив (Merge Sort):", mergeSort(dataArrayMerge));
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Временная сложность сортировки слиянием гарантированно составляет **O(n log n)** как в лучшем, так и в худшем случае. Однако этот алгоритм не является сортировкой «на месте» и требует дополнительной памяти O(n) для хранения временных массивов во время слияния.
    </p>
</section>

<section id="heapsort-explanation">
    <h1>Пирамидальная сортировка (Heapsort)</h1>
    <p>
        Пирамидальная сортировка, или сортировка кучей, — это алгоритм сортировки, основанный на структуре данных, называемой двоичной кучей (binary heap). Это сортировка «на месте» с гарантированной временной сложностью O(n log n).
    </p>

    <h2>Принцип работы</h2>
    <p>
        Алгоритм работает в два основных этапа:
    </p>
    <ul>
        <li><strong>Построение кучи (Heapify):</strong> Исходный массив преобразуется в структуру данных «максимальная куча» (max heap), где каждый родительский узел больше своих дочерних узлов, а самый большой элемент находится в корне (в начале массива).</li>
        <li><strong>Сортировка:</strong> Самый большой элемент (корень кучи) меняется местами с последним элементом массива. Размер кучи уменьшается на единицу, и оставшаяся часть массива снова преобразуется в кучу (восстанавливается свойство кучи). Этот процесс повторяется до тех пор, пока весь массив не будет отсортирован.</li>
    </ul>

    <h2>Пример кода на JavaScript</h2>
    <pre>
        <code>
// В JavaScript нет встроенной структуры данных "куча",
// поэтому реализация требует больше кода, чем для Quick Sort или Merge Sort.
// Ниже представлена базовая реализация.

function heapSort(arr) {
    let n = arr.length;

    // Строим максимальную кучу (переупорядочиваем массив)
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // Извлекаем элементы из кучи по одному
    for (let i = n - 1; i > 0; i--) {
        // Перемещаем текущий корень в конец
        [arr[0], arr[i]] = [arr[i], arr[0]];

        // Вызываем heapify на уменьшенной куче
        heapify(arr, i, 0);
    }
    return arr;
}

// Функция heapify для поддержания свойства кучи
function heapify(arr, n, i) {
    let largest = i; // Инициализируем наибольший элемент как корень
    let left = 2 * i + 1;
    let right = 2 * i + 2;

    // Если левый дочерний элемент больше корня
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // Если правый дочерний элемент больше, чем самый большой элемент на данный момент
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // Если самый большой элемент не корень
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]]; // Меняем местами

        // Рекурсивно вызываем heapify для затронутого поддерева
        heapify(arr, n, largest);
    }
}

// Пример использования:
const dataArrayHeap = [11, 8, 14, 3, 6, 2, 7, 1];
console.log("Отсортированный массив (Heapsort):", heapSort(dataArrayHeap));
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Временная сложность пирамидальной сортировки гарантирована и составляет **O(n log n)** как в среднем, так и в худшем случае. Она выполняется «на месте», что делает ее хорошим выбором, когда доступная память ограничена, хотя на практике она часто немного медленнее, чем быстрая сортировка.
    </p>
</section>
<section id="greedy-algorithms-explanation">
    <h1>Жадные алгоритмы (Greedy Algorithms)</h1>
    <p>
        Жадный алгоритм — это эвристический метод для решения задач оптимизации. На каждом шаге он выбирает самое очевидное, немедленное и локально лучшее решение, не задумываясь о долгосрочных последствиях.
    </p>

    <h2>Основные принципы</h2>
    <p>
        Хотя жадные алгоритмы не всегда гарантируют глобально оптимальное решение для всех задач, они работают для многих проблем, обладающих двумя ключевыми свойствами:
    </p>
    <ul>
        <li><strong>Свойство жадного выбора:</strong> Локально оптимальный выбор приводит к глобально оптимальному решению.</li>
        <li><strong>Оптимальная подструктура:</strong> Оптимальное решение задачи содержит в себе оптимальные решения подзадач.</li>
    </ul>

    <h2>Пример: Задача о размене монет</h2>
    <p>
        Классический пример успешного применения жадного алгоритма — задача о размене заданной суммы денег минимальным количеством монет.
    </p>
    <p>
        <strong>Задача:</strong> Даны номиналы монет (например, 50, 10, 5, 1 копейка) и сумма (например, 67 копеек). Найти минимальное количество монет для размена.
    </p>

    <h2>Пример кода на JavaScript (Задача о монетах)</h2>
    <p>
        Ниже представлен код функции на JavaScript, реализующей жадный алгоритм для размена монет.
    </p>
    <pre>
        <code>
function makeChange(amount, denominations) {
    // Деноминалы должны быть отсортированы по убыванию для корректной работы жадного подхода
    denominations.sort((a, b) => b - a);

    let result = {};
    let remainingAmount = amount;

    for (const coin of denominations) {
        if (remainingAmount >= coin) {
            // Выбираем максимально возможное количество монет текущего номинала (жадный выбор)
            const count = Math.floor(remainingAmount / coin);
            result[coin] = count;
            remainingAmount -= count * coin;
        }
    }

    if (remainingAmount === 0) {
        return result; // Возвращаем количество монет каждого номинала
    } else {
        return "Невозможно разменять заданными номиналами";
    }
}

// Пример использования:
const availableCoins = [50, 25, 10, 5, 1]; // Для стандартных номиналов работает оптимально
const targetAmount = 67;
console.log(`Размен ${targetAmount} копеек:`, makeChange(targetAmount, availableCoins));
// Вывод: { '50': 1, '10': 1, '5': 1, '1': 2 } (всего 5 монет)
        </code>
    </pre>

    <h2>Где применяются жадные алгоритмы?</h2>
    <p>
        Жадные алгоритмы используются во многих областях компьютерных наук, включая:
    </p>
    <ul>
        <li><strong>Алгоритм Дейкстры</strong> (поиск кратчайшего пути в графе).</li>
        <li><strong>Алгоритмы Прима и Краскала</strong> (построение минимального остовного дерева).</li>
        <li><strong>Кодирование Хаффмана</strong> (сжатие данных без потерь).</li>
        <li><strong>Задача о дробном рюкзаке</strong> (выбор предметов с максимальной ценностью, когда предметы можно делить).</li>
    </ul>
</section>
<section id="dynamic-programming-explanation">
    <h1>Динамическое программирование (ДП)</h1>
    <p>
        Динамическое программирование (ДП) — это не конкретный алгоритм, а метод разработки алгоритмов для решения сложных вычислительных задач. Он применяется к задачам, которые можно разбить на более простые перекрывающиеся подзадачи, и в которых оптимальное решение всей задачи зависит от оптимальных решений её подзадач (свойство оптимальной подструктуры).
    </p>

    <h2>Ключевая идея: избегание повторных вычислений</h2>
    <p>
        Основная сила ДП заключается в том, что оно решает каждую подзадачу только **один раз**, сохраняя (кэшируя) результаты в таблице или массиве. Это позволяет избежать экспоненциального роста времени выполнения, который часто возникает при наивных рекурсивных подходах.
    </p>

    <h2>Два подхода к ДП</h2>
    <ul>
        <li>
            <strong>Подход "сверху вниз" (Top-Down) с мемоизацией (Memoization):</strong>
            Решение начинается с главной задачи и рекурсивно вызывает подзадачи. Результаты подзадач кэшируются по мере их вычисления.
        </li>
        <li>
            <strong>Подход "снизу вверх" (Bottom-Up) с табулированием (Tabulation):</strong>
            Решение начинается с самых маленьких подзадач, постепенно вычисляя и заполняя таблицу результатов, пока не будет достигнут ответ для исходной (самой большой) задачи.
        </li>
    </ul>

    <h2>Пример: Числа Фибоначчи</h2>
    <p>
        Классический пример, где ДП значительно повышает эффективность — вычисление N-го числа Фибоначчи.
        Наивная рекурсия многократно пересчитывает одни и те же значения (например, `fib(3)` вызывается много раз при расчете `fib(5)`).
    </p>

    <h2>Пример кода на JavaScript (Подход "Снизу вверх" / Tabulation)</h2>
    <p>
        Ниже представлен код функции на JavaScript, использующий подход снизу вверх для вычисления N-го числа Фибоначчи.
    </p>
    <pre>
        <code>
function fibonacciDP(n) {
    if (n <= 1) {
        return n;
    }

    // Создаем таблицу (массив) для хранения результатов подзадач
    const dp = new Array(n + 1);
    dp[0] = 0;
    dp[1] = 1;

    // Заполняем таблицу снизу вверх
    for (let i = 2; i <= n; i++) {
        // Каждое следующее число вычисляется ровно один раз
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}

// Пример использования:
const nValue = 10;
console.log(`F(${nValue}) =`, fibonacciDP(nValue)); // Вывод: F(10) = 55

const largeNValue = 100;
console.log(`F(${largeNValue}) =`, fibonacciDP(largeNValue)); // Вычисляется мгновенно
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Наивная рекурсивная реализация имеет экспоненциальную временную сложность O(2ⁿ). Используя динамическое программирование (как в примере выше), мы сокращаем сложность до **O(n)** (линейная), так как каждая подзадача решается ровно один раз.
    </p>
</section>
<section id="segment-tree-explanation">
    <h1>Структура данных: Дерево отрезков (Segment Tree)</h1>
    <p>
        Дерево отрезков позволяет быстро находить агрегированные значения (например, сумму, минимум, максимум) на произвольных подотрезках исходного массива, а также точечно обновлять элементы массива.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Структура основана на принципе «разделяй и властвуй».
    </p>
    <ul>
        <li>
            <strong>Листья:</strong> Листовые узлы дерева содержат значения отдельных элементов исходного массива.
        </li>
        <li>
            <strong>Внутренние узлы:</strong> Каждый внутренний узел хранит результат определенной операции (например, сумму, минимум) над всем отрезком, который покрывают его дочерние узлы.
        </li>
        <li>
            <strong>Корень:</strong> Корень дерева содержит агрегированное значение для всего исходного массива.
        </li>
    </ul>
    <p>
        Любой запрос на непрерывном отрезке может быть представлен объединением результатов из небольшого числа (около $2 \log n$) узлов дерева.
    </p>

    <h2>Пример кода на JavaScript (для суммы отрезка)</h2>
    <p>
        Ниже представлен класс на JavaScript, реализующий дерево отрезков с операциями построения, запроса суммы на отрезке и точечного обновления. Для хранения дерева используется обычный массив.
    </p>
    <pre>
        <code>
class SegmentTree {
    constructor(arr) {
        this.n = arr.length;
        // Размер массива дерева обычно берется 4*n для гарантии достаточного места
        this.tree = new Array(4 * this.n).fill(0);
        this.build(1, 0, this.n - 1, arr);
    }

    // Рекурсивная функция построения дерева
    build(node, start, end, arr) {
        if (start === end) {
            // Листовой узел хранит исходное значение
            this.tree[node] = arr[start];
            return;
        }
        const mid = Math.floor((start + end) / 2);
        const leftChild = 2 * node;
        const rightChild = 2 * node + 1;

        // Рекурсивно строим левое и правое поддеревья
        this.build(leftChild, start, mid, arr);
        this.build(rightChild, mid + 1, end, arr);

        // Внутренний узел хранит сумму своих потомков
        this.tree[node] = this.tree[leftChild] + this.tree[rightChild];
    }

    // Функция запроса суммы на заданном отрезке [L, R]
    query(node, start, end, L, R) {
        // Если текущий отрезок полностью вне диапазона запроса
        if (start > end || start > R || end < L) {
            return 0; // Нейтральный элемент для суммы
        }

        // Если текущий отрезок полностью внутри диапазона запроса
        if (L <= start && end <= R) {
            return this.tree[node];
        }

        const mid = Math.floor((start + end) / 2);
        const leftChild = 2 * node;
        const rightChild = 2 * node + 1;

        // Рекурсивно запрашиваем обе половины и объединяем результаты
        const p1 = this.query(leftChild, start, mid, L, R);
        const p2 = this.query(rightChild, mid + 1, end, L, R);
        return p1 + p2;
    }
    
    // Функция обновления значения по индексу idx
    update(node, start, end, idx, val) {
        if (start === end) {
            // Обновляем значение в листе
            this.tree[node] = val;
            return;
        }

        const mid = Math.floor((start + end) / 2);
        const leftChild = 2 * node;
        const rightChild = 2 * node + 1;

        if (start <= idx && idx <= mid) {
            // Если индекс в левой половине, идем влево
            this.update(leftChild, start, mid, idx, val);
        } else {
            // Иначе идем в правую половину
            this.update(rightChild, mid + 1, end, idx, val);
        }

        // Обновляем текущий узел после обновления потомков
        this.tree[node] = this.tree[leftChild] + this.tree[rightChild];
    }
}

// Пример использования:
const data =;
const segTree = new SegmentTree(data);

console.log("Сумма на отрезке [1, 3]:", segTree.query(1, 0, data.length - 1, 1, 3)); // 1 + 3 + (-2) = 2

// Обновляем элемент по индексу 2 (значение -2) на 5
segTree.update(1, 0, data.length - 1, 2, 5);
console.log("Сумма на отрезке [1, 3] после обновления:", segTree.query(1, 0, data.length - 1, 1, 3)); // 1 + 3 + 5 = 9
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Благодаря древовидной структуре, как построение дерева, так и операции запроса/обновления выполняются за логарифмическое время **O(log n)**. Пространственная сложность составляет O(n), так как требуется массив размером примерно 4*n для хранения дерева.
    </p>
</section>
<section id="dsu-explanation">
    <h1>Система непересекающихся множеств (DSU/Union-Find)</h1>
    <p>
        Система непересекающихся множеств (СНМ) — это эффективная структура данных, которая отслеживает набор элементов, разделенных на несколько непересекающихся подмножеств. Каждый элемент принадлежит ровно одному множеству.
    </p>

    <h2>Основные операции</h2>
    <p>
        DSU предоставляет две основные операции, выполняющиеся за почти константное амортизированное время O(α(n)), где α — обратная функция Аккермана, которая растет крайне медленно:
    </p>
    <ul>
        <li>
            <strong>Find (Найти):</strong> Определяет, к какому множеству принадлежит данный элемент. Обычно возвращает «представителя» (или «лидера») этого множества.
        </li>
        <li>
            <strong>Union (Объединить):</strong> Объединяет два множества в одно целое.
        </li>
    </ul>

    <h2>Принцип работы и реализация</h2>
    <p>
        Чаще всего СНМ реализуется в виде леса нетрадиционных деревьев, где каждый узел хранит ссылку только на своего родителя. Представителем множества является корень дерева. Для оптимизации используются два метода:
    </p>
    <ul>
        <li>
            <strong>Сжатие путей (Path Compression):</strong> Во время операции `Find` все узлы на пути от элемента до корня переподключаются напрямую к корню, что ускоряет будущие операции поиска.
        </li>
        <li>
            <strong>Объединение по рангу/размеру (Union by Rank/Size):</strong> При объединении двух деревьев меньшее дерево всегда присоединяется к большему, чтобы минимизировать высоту результирующего дерева.
        </li>
    </ul>

    <h2>Пример кода на JavaScript (с оптимизациями)</h2>
    <p>
        Ниже представлен класс на JavaScript, реализующий DSU с оптимизациями сжатия путей и объединения по размеру.
    </p>
    <pre>
        <code>
class DisjointSetUnion {
    constructor(size) {
        this.parent = new Array(size);
        this.size = new Array(size);
        for (let i = 0; i < size; i++) {
            this.parent[i] = i; // Изначально каждый элемент — сам себе родитель
            this.size[i] = 1;   // Изначально размер каждого множества равен 1
        }
    }

    // Операция Find с сжатием путей
    find(i) {
        if (this.parent[i] === i) {
            return i; // Если элемент является корнем, возвращаем его
        }
        // Сжатие путей: переподключаем узел напрямую к корню
        this.parent[i] = this.find(this.parent[i]);
        return this.parent[i];
    }

    // Операция Union по размеру
    union(i, j) {
        const rootI = this.find(i);
        const rootJ = this.find(j);

        if (rootI !== rootJ) {
            // Объединение: меньшее дерево присоединяем к большему
            if (this.size[rootI] < this.size[rootJ]) {
                this.parent[rootI] = rootJ;
                this.size[rootJ] += this.size[rootI];
            } else {
                this.parent[rootJ] = rootI;
                this.size[rootI] += this.size[rootJ];
            }
            return true; // Множества были объединены
        }
        return false; // Элементы уже в одном множестве
    }
}

// Пример использования:
const dsu = new DisjointSetUnion(5); // Элементы 0, 1, 2, 3, 4

dsu.union(0, 1); // Объединяем {0} и {1}
dsu.union(1, 2); // Объединяем {1, 2} и {2} -> {0, 1, 2}
dsu.union(3, 4); // Объединяем {3} и {4}

console.log("В одном ли множестве 0 и 2?", dsu.find(0) === dsu.find(2)); // true
console.log("В одном ли множестве 0 и 3?", dsu.find(0) === dsu.find(3)); // false

dsu.union(0, 3); // Объединяем {0, 1, 2} и {3, 4}
console.log("В одном ли множестве 0 и 3 после объединения?", dsu.find(0) === dsu.find(3)); // true
        </code>
    </pre>

    <h2>Применение</h2>
    <p>
        DSU широко используется для решения задач, связанных со связностью компонентов:
    </p>
    <ul>
        <li><strong>Алгоритм Крускала</strong> для поиска минимального остовного дерева в графе.</li>
        <li>Определение наличия циклов в неориентированном графе.</li>
        <li>Подсчет количества связных компонентов в графе или сети (например, в задаче "Количество провинций" на LeetCode).</li>
    </ul>
</section>
<section id="queue-explanation">
    <h1>Структура данных: Очередь (Queue)</h1>
    <p>
        Очередь — это линейная структура данных, которая работает по принципу **FIFO (First-In, First-Out)**, что означает «первым пришел — первым вышел». Это имитирует реальную очередь людей в магазине: первый человек в очереди обслуживается первым.
    </p>

    <h2>Основные операции</h2>
    <ul>
        <li><strong>Enqueue (поставить в очередь):</strong> Добавляет элемент в конец (хвост) очереди.</li>
        <li><strong>Dequeue (извлечь из очереди):</strong> Удаляет и возвращает элемент из начала (головы) очереди.</li>
        <li><strong>Peek (посмотреть):</strong> Позволяет просмотреть первый элемент без его удаления.</li>
        <li><strong>isEmpty (проверить на пустоту):</strong> Проверяет, пуста ли очередь.</li>
    </ul>

    <h2>Пример использования: Очередь печати</h2>
    <p>
        В операционной системе задания на печать помещаются в очередь. Принтер обрабатывает их строго в том порядке, в котором они были отправлены на печать.
    </p>

    <h2>Пример кода на JavaScript (используя массив)</h2>
    <p>
        В JavaScript для имитации очереди можно использовать методы <code>push()</code> (для добавления в конец) и <code>shift()</code> (для удаления из начала).
    </p>
    <pre>
        <code>
class Queue {
    constructor() {
        this.items = [];
    }

    // Добавление элемента в конец очереди
    enqueue(element) {
        this.items.push(element);
    }

    // Удаление элемента из начала очереди
    dequeue() {
        if (this.items.length === 0) {
            return "Очередь пуста";
        }
        // Метод shift() удаляет первый элемент массива и переиндексирует остальные
        return this.items.shift();
    }

    // Просмотр первого элемента
    peek() {
        return this.items[0];
    }

    isEmpty() {
        return this.items.length === 0;
    }
}

// Пример использования:
const queue = new Queue();
queue.enqueue('Задача A');
queue.enqueue('Задача B');
queue.enqueue('Задача C');
console.log("Очередь:", queue.items); // Вывод: [ 'Задача A', 'Задача B', 'Задача C' ]

console.log("Обработанная задача:", queue.dequeue()); // Вывод: Задача A
console.log("Очередь после dequeue:", queue.items); // Вывод: [ 'Задача B', 'Задача C' ]
        </code>
    </pre>
</section>
<section id="stack-explanation">
    <h1>Структура данных: Стек (Stack)</h1>
    <p>
        Стек — это линейная структура данных, которая работает по принципу **LIFO (Last-In, First-Out)**, что означает «последним пришел — первым вышел». Представьте себе стопку тарелок: вы всегда берете верхнюю (последнюю положенную) тарелку, и добавляете новые тарелки тоже сверху.
    </p>

    <h2>Основные операции</h2>
    <ul>
        <li><strong>Push (добавить):</strong> Добавляет элемент на вершину стека.</li>
        <li><strong>Pop (извлечь):</strong> Удаляет и возвращает элемент с вершины стека.</li>
        <li><strong>Peek (посмотреть):</strong> Позволяет просмотреть верхний элемент без его удаления.</li>
        <li><strong>isEmpty (проверить на пустоту):</strong> Проверяет, пуст ли стек.</li>
    </ul>

    <h2>Пример использования: Отмена действий (Undo)</h2>
    <p>
        В текстовом редакторе каждое изменение помещается в стек. Когда пользователь нажимает «Отменить» (Ctrl+Z), удаляется и отменяется самое последнее (верхнее) изменение.
    </p>

    <h2>Пример кода на JavaScript (используя массив)</h2>
    <p>
        В JavaScript массив можно легко использовать как стек, применяя встроенные методы <code>push()</code> и <code>pop()</code>, которые работают с концом массива.
    </p>
    <pre>
        <code>
class Stack {
    constructor() {
        this.items = [];
    }

    // Добавление элемента на вершину стека (конец массива)
    push(element) {
        this.items.push(element);
    }

    // Удаление элемента с вершины стека (конца массива)
    pop() {
        if (this.items.length === 0) {
            return "Стек пуст";
        }
        return this.items.pop();
    }

    // Просмотр верхнего элемента
    peek() {
        return this.items[this.items.length - 1];
    }

    isEmpty() {
        return this.items.length === 0;
    }
}

// Пример использования:
const stack = new Stack();
stack.push('Книга 1');
stack.push('Книга 2');
stack.push('Книга 3');
console.log("Стек:", stack.items); // Вывод: [ 'Книга 1', 'Книга 2', 'Книга 3' ]

console.log("Извлеченный элемент:", stack.pop()); // Вывод: Книга 3
console.log("Стек после pop:", stack.items); // Вывод: [ 'Книга 1', 'Книга 2' ]
        </code>
    </pre>
</section>
<section id="hash-table-explanation">
    <h1>Структура данных: Хеш-таблица (Hash Table)</h1>
    <p>
        Хеш-таблица — это структура данных, реализующая ассоциативный массив (карту) для хранения пар «ключ-значение». Она использует <strong>хеш-функцию</strong> для преобразования ключа в индекс в базовом массиве (ведре), что обеспечивает быстрое извлечение и вставку данных со средней временной сложностью $O(1)$.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Работа хеш-таблицы основана на нескольких ключевых компонентах:
    </p>
    <ul>
        <li>
            <strong>Хеш-функция:</strong> Преобразует входной ключ (например, строку или число) в числовое хеш-значение.
        </li>
        <li>
            <strong>Индексирование:</strong> Хеш-значение используется для вычисления индекса (обычно с помощью операции по модулю от размера массива) в массиве для хранения или извлечения значения.
        </li>
        <li>
            <strong>Разрешение коллизий:</strong> Когда два разных ключа дают одинаковый индекс, возникает коллизия. Для их разрешения часто применяют метод <strong>цепочек</strong> (хранение нескольких элементов в виде списка или массива в одном ведре).
        </li>
    </ul>

    <h2>Пример кода на JavaScript (с методом цепочек)</h2>
    <p>
        Ниже представлен класс на JavaScript, реализующий простую хеш-таблицу с использованием метода цепочек (каждое ведро хранит массив пар <code>[key, value]</code>) для разрешения коллизий.
    </p>
    <pre>
        <code>
class HashTable {
    // Начальный размер таблицы (количество ведер)
    constructor(size = 10) {
        this.size = size;
        // Создаем массив ведер, каждое из которых инициализируется пустым массивом для цепочек
        this.buckets = new Array(this.size).fill(null).map(() => []);
    }

    // Простая хеш-функция, использующая сумму ASCII-кодов символов ключа
    _hash(key) {
        let hashValue = 0;
        for (let i = 0; i < key.length; i++) {
            hashValue += key.charCodeAt(i);
        }
        // Возвращаем индекс в пределах размера таблицы
        return hashValue % this.size;
    }

    // Метод добавления или обновления пары ключ-значение
    set(key, value) {
        const index = this._hash(key);
        const bucket = this.buckets[index];

        // Проверяем, существует ли уже ключ в ведре, и обновляем его
        for (let i = 0; i < bucket.length; i++) {
             // bucket[i][0] это ключ
            if (bucket[i][0] === key) { 
                bucket[i][1] = value; // Обновляем значение (bucket[i][1])
                return;
            }
        }

        // Если ключа нет, добавляем новую пару [key, value] в ведро
        bucket.push([key, value]);
    }

    // Метод получения значения по ключу
    get(key) {
        const index = this._hash(key);
        const bucket = this.buckets[index];

        // Ищем ключ в ведре и возвращаем значение
        for (let i = 0; i < bucket.length; i++) {
             // bucket[i][0] это ключ
            if (bucket[i][0] === key) {
                return bucket[i][1]; // Возвращаем значение (bucket[i][1])
            }
        }

        // Если ключ не найден
        return undefined;
    }

    // Метод удаления пары по ключу
    remove(key) {
        const index = this._hash(key);
        const bucket = this.buckets[index];

        // Находим и удаляем пару, если она существует
        for (let i = 0; i < bucket.length; i++) {
             // bucket[i][0] это ключ
            if (bucket[i][0] === key) {
                bucket.splice(i, 1); // Удаляем элемент из массива
                return true; // Успешно удалено
            }
        }

        return false; // Ключ не найден
    }
}

// Пример использования:
const myHashTable = new HashTable(50);

myHashTable.set('name', 'Alice');
myHashTable.set('age', 30);
myHashTable.set('city', 'New York');

console.log("Имя:", myHashTable.get('name')); // Output: Alice
console.log("Возраст:", myHashTable.get('age')); // Output: 30
console.log("Город:", myHashTable.get('city')); // Output: New York

myHashTable.set('name', 'Bob'); // Обновляем имя
console.log("Новое имя:", myHashTable.get('name')); // Output: Bob

myHashTable.remove('age');
console.log("Возраст после удаления:", myHashTable.get('age')); // Output: undefined
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        В среднем, хеш-таблицы демонстрируют высокую эффективность:
    </p>
    <ul>
        <li>
            <strong>Вставка (set), получение (get), удаление (remove):</strong> Средняя временная сложность составляет <strong>O(1)</strong>.
        </li>
        <li>
            <strong>Худший случай:</strong> Если хеш-функция плохо распределяет ключи (например, все ключи попадают в одно ведро), сложность операций может возрасти до <strong>O(n)</strong>, так как приходится выполнять линейный поиск в длинной цепочке.
        </li>
        <li>
            <strong>Пространственная сложность:</strong> <strong>O(n)</strong>, поскольку требуется место для хранения всех пар «ключ-значение».
        </li>
    </ul>
</section>
<section id="bfs-explanation">
    <h1>Алгоритм: Поиск в ширину (Breadth-First Search, BFS)</h1>
    <p>
        <strong>Поиск в ширину (BFS)</strong> — это алгоритм обхода графа или дерева, который исследует граф поуровнево: сначала посещает все вершины, смежные с начальной вершиной (на уровне 1), затем все их непосещенные соседние вершины (на уровне 2), и так далее. Этот алгоритм гарантирует нахождение кратчайшего пути в невзвешенном графе.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Для реализации BFS используется структура данных <strong>очередь (Queue)</strong>.
    </p>
    <ul>
        <li>
            <strong>Инициализация:</strong> Алгоритм начинается с выбора стартовой вершины, которая помечается как посещенная и добавляется в очередь.
        </li>
        <li>
            <strong>Обход:</strong> Пока очередь не пуста, из нее извлекается (удаляется из начала) текущая вершина.
        </li>
        <li>
            <strong>Исследование соседей:</strong> Все непосещенные соседи текущей вершины помечаются как посещенные и добавляются в конец очереди.
        </li>
        <li>
            <strong>Повторение:</strong> Процесс повторяется до тех пор, пока не будут посещены все достижимые вершины.
        </li>
    </ul>

    <h2>Пример кода на JavaScript (для обхода графа)</h2>
    <p>
        Ниже представлен класс на JavaScript, реализующий алгоритм поиска в ширину для заданного графа, представленного в виде списка смежности (ассоциативного массива).
    </p>
    <pre>
        <code>
// Функция, выполняющая обход графа в ширину
function breadthFirstSearch(graph, startNode) {
    const visited = new Set(); // Множество для отслеживания посещенных вершин
    const queue = [startNode]; // Очередь, инициализированная стартовой вершиной
    const result = []; // Массив для хранения порядка обхода

    visited.add(startNode);

    while (queue.length > 0) {
        const currentNode = queue.shift(); // Извлекаем вершину из начала очереди
        result.push(currentNode); // Добавляем в результат обхода

        // Перебираем всех соседей текущей вершины
        for (const neighbor of graph[currentNode]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor); // Помечаем как посещенную
                queue.push(neighbor); // Добавляем в конец очереди
            }
        }
    }

    return result; // Возвращаем последовательность обхода
}

// Пример графа (список смежности)
const graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
};

// Запуск алгоритма с начальной вершины 'A'
const traversalOrder = breadthFirstSearch(graph, 'A');
console.log("Порядок обхода BFS, начиная с 'A':", traversalOrder); 
// Output: Порядок обхода BFS, начиная с 'A': [ 'A', 'B', 'C', 'D', 'E', 'F' ]
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Временная и пространственная сложность алгоритма BFS зависит от количества вершин ($V$) и ребер ($E$) в графе.
    </p>
    <ul>
        <li>
            <strong>Временная сложность:</strong> <strong>O(V + E)</strong>, так как каждая вершина и каждое ребро посещаются (в худшем случае) ровно один раз.
        </li>
        <li>
            <strong>Пространственная сложность:</strong> <strong>O(V)</strong>, так как для хранения посещенных вершин и очереди требуется дополнительная память, пропорциональная количеству вершин в худшем случае (когда все вершины находятся на одном уровне).
        </li>
    </ul>
</section>
<section id="mst-algorithms-explanation">
    <h1>Алгоритмы поиска минимального остовного дерева (МОД): Прима и Крускала</h1>
    <p>
        Алгоритмы **Прима** и **Крускала** решают одну и ту же задачу: нахождение **минимального остовного дерева (МОД)** во взвешенном неориентированном графе. МОД — это подграф, который соединяет все вершины исходного графа с минимальным суммарным весом рёбер и не содержит циклов.
    </p>

    <h2>Ключевое различие в подходах</h2>
    <p>
        Несмотря на общую цель, алгоритмы используют разную логику построения дерева:
    </p>

    <h3>Алгоритм Прима (Prim's Algorithm)</h3>
    <ul>
        <li>
            **Подход на основе вершин:** Начинает с одной произвольной вершины и постепенно «разрастается», добавляя вершины одну за другой.
        </li>
        <li>
            **Метод:** На каждом шаге выбирает самое дешевое ребро, которое соединяет *текущее построенное дерево* с *еще не включенной* вершиной.
        </li>
        <li>
            **Структура данных:** Использует очередь с приоритетом для выбора следующего ребра.
        </li>
        <li>
            **Эффективность:** Лучше работает на **плотных графах** ($O(V^2)$ или $O(E \log V)$).
        </li>
    </ul>

    <h3>Алгоритм Крускала (Kruskal's Algorithm)</h3>
    <ul>
        <li>
            **Подход на основе рёбер:** Начинает с набора отдельных вершин (каждая в своем собственном множестве) и постепенно добавляет рёбра.
        </li>
        <li>
            **Метод:** Сортирует все рёбра по весу и последовательно добавляет их, только если это не приводит к образованию цикла.
        </li>
        <li>
            **Структура данных:** Использует систему непересекающихся множеств (**DSU**) для быстрой проверки циклов (операции `find` и `union`).
        </li>
        <li>
            **Эффективность:** Лучше работает на **разреженных графах** ($O(E \log E)$ или $O(E \log V)$).
        </li>
    </ul>

    <h2>Резюме</h2>
    <p>
        Прим расширяет один связный компонент, а Крускал объединяет множество мелких компонентов в один большой. Оба алгоритма являются "жадными" и гарантируют нахождение МОД.
    </p>
</section>
<section id="floyd-warshall-explanation">
    <h1>Алгоритм: Флойда-Уоршелла (Floyd-Warshall Algorithm)</h1>
    <p>
        **Алгоритм Флойда-Уоршелла** — это алгоритм динамического программирования, предназначенный для поиска кратчайших путей между <em>всеми парами</em> вершин во взвешенном ориентированном или неориентированном графе. Он корректно работает с рёбрами отрицательного веса, но **не работает**, если в графе присутствуют циклы с отрицательным суммарным весом.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Алгоритм использует идею постепенного улучшения оценок кратчайших путей. Он оперирует матрицей смежности, которая изначально содержит прямые веса рёбер (или бесконечность, если прямого ребра нет).
    </p>
    <ul>
        <li>
            <strong>Инициализация:</strong> Создается матрица расстояний `dist[i][j]`, где начальное значение равно весу прямого ребра из вершины `i` в `j`. Если ребра нет, устанавливается значение "бесконечность". Расстояние от вершины до самой себя равно 0.
        </li>
        <li>
            <strong>Итерации:</strong> Алгоритм выполняет три вложенных цикла. Внешний цикл перебирает каждую вершину $k$ в качестве *промежуточной* точки на пути между всеми возможными парами вершин $i$ и $j$.
        </li>
        <li>
            <strong>Обновление:</strong> Для каждой пары $(i, j)$ проверяется условие: является ли путь через промежуточную вершину $k$ (т.е. $dist[i][k] + dist[k][j]$) короче, чем текущий кратчайший путь $dist[i][j]$? Если да, расстояние обновляется: $dist[i][j] = dist[i][k] + dist[k][j]$.
        </li>
        <li>
            <strong>Завершение:</strong> После завершения всех итераций матрица `dist` содержит длины кратчайших путей между всеми парами вершин.
        </li>
    </ul>

    <h2>Пример кода на JavaScript (с использованием матрицы смежности)</h2>
    <p>
        Ниже представлен код, реализующий алгоритм Флойда-Уоршелла. Входные данные представлены в виде двумерного массива (матрицы смежности).
    </p>
    <pre>
        <code>
function floydWarshall(graph) {
    const V = graph.length; // Количество вершин
    // Копируем исходную матрицу расстояний, чтобы не изменять оригинал
    let dist = []; 
    for (let i = 0; i < V; i++) {
        dist[i] = [...graph[i]];
    }

    // Три вложенных цикла: k - промежуточная вершина, i - стартовая, j - конечная
    for (let k = 0; k < V; k++) {
        for (let i = 0; i < V; i++) {
            for (let j = 0; j < V; j++) {
                // Проверяем, можно ли улучшить путь из i в j через k
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    // Дополнительная проверка на наличие циклов отрицательного веса (опционально)
    for (let i = 0; i < V; i++) {
        if (dist[i][i] < 0) {
            console.log("Обнаружен цикл отрицательного веса!");
            // В таком случае кратчайшие пути не определены
            return null; 
        }
    }

    return dist;
}

// Пример графа в виде матрицы смежности
// INF (Infinity) используется для обозначения отсутствия прямого ребра
const INF = Infinity;
const graphMatrix = [
    // A   B   C   D
    [0,  2,  INF, 5], // A
    [INF, 0,  1,  INF], // B
    [2,  INF, 0,  3], // C
    [INF, INF, 1,  0]  // D
];

const shortestPaths = floydWarshall(graphMatrix);
console.log("Матрица кратчайших расстояний (Floyd-Warshall):");
console.log(shortestPaths);
/*
Output:
[
  [ 0, 2, 3, 5 ],
  [ 2, 0, 1, 4 ],
  [ 2, 4, 0, 3 ],
  [ 3, 5, 1, 0 ]
]
*/
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Алгоритм Флойда-Уоршелла имеет детерминированную кубическую сложность благодаря трем вложенным циклам, независимо от плотности графа.
    </p>
    <ul>
        <li>
            <strong>Временная сложность:</strong> **O(V³)**, где V — количество вершин в графе.
        </li>
        <li>
            <strong>Пространственная сложность:</strong> **O(V²)**, так как требуется матрица для хранения всех пар кратчайших путей.
        </li>
    </ul>
</section>
<section id="dijkstra-explanation">
    <h1>Алгоритм: Дейкстры (Dijkstra's Algorithm)</h1>
    <p>
        <strong>Алгоритм Дейкстры</strong> — это алгоритм поиска кратчайшего пути от одной начальной вершины до всех других вершин во взвешенном графе с <strong>неотрицательными</strong> весами ребер. Он широко используется в маршрутизации (например, в Google Maps) и других задачах, где требуется найти наиболее оптимальный путь или минимальную стоимость.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Алгоритм Дейкстры является примером "жадного" алгоритма (greedy algorithm), который на каждом шаге выбирает локально оптимальное решение. Для эффективной работы часто используется структура данных <strong>очередь с приоритетом (Priority Queue)</strong>.
    </p>
    <ul>
        <li>
            <strong>Инициализация:</strong> Дистанции до всех вершин устанавливаются как бесконечность ($\infty$), кроме стартовой вершины, дистанция до которой равна 0. Все вершины считаются непосещенными.
        </li>
        <li>
            <strong>Выбор вершины:</strong> Из множества непосещенных вершин выбирается та, у которой текущее кратчайшее расстояние от старта наименьшее. Изначально это стартовая вершина.
        </li>
        <li>
            <strong>Обновление дистанций:</strong> Для всех непосещенных соседей выбранной вершины вычисляется новое расстояние через текущую вершину (<code>текущее_расстояние + вес_ребра</code>). Если новое расстояние меньше уже известного кратчайшего расстояния до соседа, оно обновляется.
        </li>
        <li>
            <strong>Завершение:</strong> Выбранная вершина помечается как посещенная и удаляется из набора непосещенных вершин. Процесс повторяется, пока не будут посещены все вершины или пока не будет найдена целевая вершина.
        </li>
    </ul>

    <h2>Пример кода на JavaScript (с использованием вспомогательной очереди с приоритетом)</h2>
    <p>
        Для эффективной реализации алгоритма на JavaScript без встроенной структуры очереди с приоритетом, мы имитируем её с помощью простого массива и сортировки (что замедляет работу по сравнению с нативной структурой данных).
    </p>
    <pre>
        <code>
// Вспомогательный класс для имитации базовой очереди с приоритетом 
// (Используется массив с сортировкой, что имеет сложность O(n log n) при добавлении)
class PriorityQueue {
    constructor() {
        this.collection = [];
    }
    enqueue(element, priority) {
        this.collection.push({element, priority});
        this.sort();
    }
    dequeue() {
        return this.collection.shift();
    }
    sort() {
        // Сортировка по приоритету (меньшее значение - выше приоритет)
        this.collection.sort((a, b) => a.priority - b.priority);
    }
    isEmpty() {
        return this.collection.length === 0;
    }
}

function dijkstra(graph, start) {
    const distances = {}; // Кратчайшие расстояния от старта
    const pq = new PriorityQueue();
    const visited = new Set();
    
    // Инициализация расстояний
    for (let node in graph) {
        distances[node] = Infinity;
    }
    distances[start] = 0;

    pq.enqueue(start, 0);

    while (!pq.isEmpty()) {
        const {element: currentNode, priority: currentDistance} = pq.dequeue();

        // Если вершина уже посещена с меньшим расстоянием, пропускаем
        if (visited.has(currentNode)) continue;
        visited.add(currentNode);

        // Обновление расстояний соседей
        for (let neighbor in graph[currentNode]) {
            const weight = graph[currentNode][neighbor];
            const distanceThroughCurrent = currentDistance + weight;

            if (distanceThroughCurrent < distances[neighbor]) {
                distances[neighbor] = distanceThroughCurrent;
                // Добавляем соседа в очередь с новым приоритетом (расстоянием)
                pq.enqueue(neighbor, distanceThroughCurrent);
            }
        }
    }

    return distances;
}

// Пример графа (список смежности с весами)
const graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'D': 2, 'E': 5},
    'C': {'A': 4, 'F': 3},
    'D': {'B': 2, 'E': 1},
    'E': {'B': 5, 'D': 1, 'F': 2},
    'F': {'C': 3, 'E': 2}
};

const shortestDistances = dijkstra(graph, 'A');
console.log("Кратчайшие расстояния от вершины 'A':", shortestDistances);
// Output (примерный): { A: 0, B: 1, C: 4, D: 3, E: 4, F: 6 }
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Временная сложность алгоритма Дейкстры зависит от используемой структуры данных для хранения вершин с их текущими расстояниями.
    </p>
    <ul>
        <li>
            <strong>С простым массивом:</strong> Сложность составляет **O(V²)**, где V — количество вершин.
        </li>
        <li>
            <strong>С очередью с приоритетом (например, бинарной кучей):</strong> Сложность улучшается до **O((V + E) log V)**, где E — количество ребер.
        </li>
        <li>
            <strong>Пространственная сложность:</strong> **O(V + E)** для хранения графа, расстояний и предыдущих вершин.
        </li>
    </ul>
</section>
<section id="dfs-explanation">
    <h1>Алгоритм: Поиск в глубину (Depth-First Search, DFS)</h1>
    <p>
        <strong>Поиск в глубину (DFS)</strong> — это алгоритм обхода графа или дерева, который исследует граф «вглубь» настолько далеко, насколько это возможно, прежде чем вернуться (выполнить возврат) и исследовать другие ветви. DFS можно реализовать как итеративно (используя стек), так и рекурсивно (что неявно использует стек вызовов).
    </p>

    <h2>Принцип работы</h2>
    <p>
        Для реализации итеративного DFS используется структура данных <strong>стек (Stack)</strong>.
    </p>
    <ul>
        <li>
            <strong>Инициализация:</strong> Алгоритм начинается с выбора стартовой вершины, которая помечается как посещенная и добавляется в стек.
        </li>
        <li>
            <strong>Обход:</strong> Пока стек не пуст, из него извлекается (удаляется из вершины) текущая вершина.
        </li>
        <li>
            <strong>Исследование соседей:</strong> Выбирается один из непосещенных соседей текущей вершины, помечается как посещенный и добавляется в стек. Процесс продолжается до достижения «дна». Если непосещенных соседей нет, происходит возврат (backtracking) к предыдущей вершине в стеке.
        </li>
        <li>
            <strong>Повторение:</strong> Процесс повторяется до тех пор, пока не будут посещены все достижимые вершины.
        </li>
    </ul>

    <h2>Пример кода на JavaScript (рекурсивный обход графа)</h2>
    <p>
        Ниже представлен класс на JavaScript, реализующий алгоритм поиска в глубину для заданного графа, представленного в виде списка смежности (ассоциативного массива), с использованием рекурсивного подхода.
    </p>
    <pre>
        <code>
// Функция, выполняющая обход графа в глубину (рекурсивно)
function depthFirstSearch(graph, startNode) {
    const visited = new Set(); // Множество для отслеживания посещенных вершин
    const result = []; // Массив для хранения порядка обхода

    // Внутренняя рекурсивная функция DFS
    function dfsRecursive(node) {
        if (!node || visited.has(node)) {
            return;
        }

        visited.add(node); // Помечаем текущую вершину как посещенную
        result.push(node); // Добавляем в результат обхода

        // Рекурсивно вызываем DFS для всех соседей текущей вершины
        for (const neighbor of graph[node]) {
            dfsRecursive(neighbor);
        }
    }

    dfsRecursive(startNode);
    return result; // Возвращаем последовательность обхода
}

// Пример графа (список смежности)
const graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
};

// Запуск алгоритма с начальной вершины 'A'
const traversalOrder = depthFirstSearch(graph, 'A');
console.log("Порядок обхода DFS, начиная с 'A':", traversalOrder); 
// Output: Порядок обхода DFS, начиная с 'A': [ 'A', 'B', 'D', 'E', 'F', 'C' ] 
// (Порядок может незначительно меняться в зависимости от порядка соседей в списке смежности)
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Временная и пространственная сложность алгоритма DFS зависит от количества вершин ($V$) и ребер ($E$) в графе.
    </p>
    <ul>
        <li>
            <strong>Временная сложность:</strong> **O(V + E)**, так как каждая вершина и каждое ребро посещаются (в худшем случае) ровно один раз.
        </li>
        <li>
            <strong>Пространственная сложность:</strong> **O(V)**, так как для хранения посещенных вершин требуется память, а в худшем случае (например, при обходе очень глубокого дерева) глубина стека вызовов может достигать $O(V)$.
        </li>
    </ul>
</section>
<section id="bfs-explanation">
    <h1>Алгоритм: Поиск в ширину (Breadth-First Search, BFS)</h1>
    <p>
        <strong>Поиск в ширину (BFS)</strong> — это алгоритм обхода графа или дерева, который исследует граф поуровнево: сначала посещает все вершины, смежные с начальной вершиной (на уровне 1), затем все их непосещенные соседние вершины (на уровне 2), и так далее. Этот алгоритм гарантирует нахождение кратчайшего пути в невзвешенном графе.
    </p>

    <h2>Принцип работы</h2>
    <p>
        Для реализации BFS используется структура данных <strong>очередь (Queue)</strong>.
    </p>
    <ul>
        <li>
            <strong>Инициализация:</strong> Алгоритм начинается с выбора стартовой вершины, которая помечается как посещенная и добавляется в очередь.
        </li>
        <li>
            <strong>Обход:</strong> Пока очередь не пуста, из нее извлекается (удаляется из начала) текущая вершина.
        </li>
        <li>
            <strong>Исследование соседей:</strong> Все непосещенные соседи текущей вершины помечаются как посещенные и добавляются в конец очереди.
        </li>
        <li>
            <strong>Повторение:</strong> Процесс повторяется до тех пор, пока не будут посещены все достижимые вершины.
        </li>
    </ul>

    <h2>Пример кода на JavaScript (для обхода графа)</h2>
    <p>
        Ниже представлен класс на JavaScript, реализующий алгоритм поиска в ширину для заданного графа, представленного в виде списка смежности (ассоциативного массива).
    </p>
    <pre>
        <code>
// Функция, выполняющая обход графа в ширину
function breadthFirstSearch(graph, startNode) {
    const visited = new Set(); // Множество для отслеживания посещенных вершин
    const queue = [startNode]; // Очередь, инициализированная стартовой вершиной
    const result = []; // Массив для хранения порядка обхода

    visited.add(startNode);

    while (queue.length > 0) {
        const currentNode = queue.shift(); // Извлекаем вершину из начала очереди
        result.push(currentNode); // Добавляем в результат обхода

        // Перебираем всех соседей текущей вершины
        for (const neighbor of graph[currentNode]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor); // Помечаем как посещенную
                queue.push(neighbor); // Добавляем в конец очереди
            }
        }
    }

    return result; // Возвращаем последовательность обхода
}

// Пример графа (список смежности)
const graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
};

// Запуск алгоритма с начальной вершины 'A'
const traversalOrder = breadthFirstSearch(graph, 'A');
console.log("Порядок обхода BFS, начиная с 'A':", traversalOrder); 
// Output: Порядок обхода BFS, начиная с 'A': [ 'A', 'B', 'C', 'D', 'E', 'F' ]
        </code>
    </pre>

    <h2>Сложность алгоритма</h2>
    <p>
        Временная и пространственная сложность алгоритма BFS зависит от количества вершин ($V$) и ребер ($E$) в графе.
    </p>
    <ul>
        <li>
            <strong>Временная сложность:</strong> <strong>O(V + E)</strong>, так как каждая вершина и каждое ребро посещаются (в худшем случае) ровно один раз.
        </li>
        <li>
            <strong>Пространственная сложность:</strong> <strong>O(V)</strong>, так как для хранения посещенных вершин и очереди требуется дополнительная память, пропорциональная количеству вершин в худшем случае (когда все вершины находятся на одном уровне).
        </li>
    </ul>
</section>

</body>
</html>
